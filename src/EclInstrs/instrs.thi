/*

Ecl instructions for lasers

*/

laserNew @ 700 (int etid, float i_l, float f_l, float arg3, float w) {
    enemy.BSs[etid].__vec3_8 = {i_l, f_l, arg3};
    enemy.BSs[etid].__laser_new_arg_4 = w;
}

laserTiming @ 701 (int etid, int start_t, int tr1_t, int dur, int tr2_t, int end_t) {
    enemy.BSs[etid].__laser_timing_start    = start_t;
    enemy.BSs[etid].__laser_timing_trans1   = tr1_t;
    enemy.BSs[etid].__laser_timing_duration = dur;
    enemy.BSs[etid].__laser_timing_trans2   = tr2_t;
    enemy.BSs[etid].__laser_timing_end      = end_t;
}

laserOn @ 702 (int etid) {
    LaserLineInner_t inner;

    for (int i = 0; i < 20; i++) inner.et_ex[i] = enemy.BSs[etid].ex[i];

    if (enemy.bulletOrigins[etid].z <= 0.9f) {
        inner.start_pos = enemy.final_pos.pos + enemy.bulletOffsets[etid];
    } else {
        inner.start_pos = {
            enemy.bulletOrigins[etid].x + enemy.bulletOffsets[etid].x,
            enemy.bulletOrigins[etid].y + enemy.bulletOffsets[etid].y,
            0.f
        };
    }

    inner.ang_aim            = enemy.BSs[etid].ang_aim;
    inner.laser_new_arg_2    = enemy.BSs[etid].__vec3_8.y;
    inner.laser_new_arg_1    = enemy.BSs[etid].__vec3_8.x;
    inner.laser_new_arg_3    = enemy.BSs[etid].__vec3_8.z;
    inner.laser_new_arg_4    = enemy.BSs[etid].__laser_new_arg_4;
    inner.spd_1              = enemy.BSs[etid].spd1;
    inner.bullet_type        = enemy.BSs[etid].type;
    inner.bullet_color       = enemy.BSs[etid].__color;
    inner.distance           = enemy.BSs[etid].distance;
    inner.flags              = enemy.BSs[etid].__laser_timing_end | 1;
    inner.shot_sfx           = enemy.BSs[etid].shot_sfx;
    inner.shot_transform_sfx = enemy.BSs[etid].__shot_transform_sfx;

    allocate_new_laser(0, &inner);
}

laserStOn @ 703 (int etid, int& id) {
    LaserInfiniteInner_t inner;

    for (int i = 0; i < 20; i++) inner.ex[i] = enemy.BSs[etid].ex[i];

    if (enemy.bulletOrigins[etid].z <= 0.9f) {
        inner.start_pos = enemy.final_pos.pos + enemy.bulletOffsets[etid];
    } else {
        inner.start_pos = {
            enemy.bulletOrigins[etid].x + enemy.bulletOffsets[etid].x,
            enemy.bulletOrigins[etid].y + enemy.bulletOffsets[etid].y,
            0.f
        };
    }

    inner.type = enemy.BSs[etid].type;
    inner.color = enemy.BSs[etid].__color;
    inner.ang_aim = enemy.BSs[etid].ang_aim;
    inner.laser_time_start = enemy.BSs[etid].__laser_timing_start;
    inner.laser_trans_1 = enemy.BSs[etid].__laser_timing_trans1;
    inner.laser_duration = enemy.BSs[etid].__laser_timing_duration;
    inner.laser_trans_2 = enemy.BSs[etid].__laser_timing_trans2;
    inner.spd_1 = enemy.BSs[etid].spd1;
    inner.flags = enemy.BSs[etid].__laser_timing_end | 2;
    inner.laser_new_arg2    = enemy.BSs[etid].__vec3_8.y;
    inner.laser_new_arg1    = enemy.BSs[etid].__vec3_8.x;
    inner.laser_new_arg4    = enemy.BSs[etid].__laser_new_arg_4;
    inner.shot_sfx = enemy.BSs[etid].shot_sfx;
    inner.distance = enemy.BSs[etid].distance;
    inner.shot_transform_sfx = enemy.BSs[etid].__shot_transform_sfx;
    inner.laser_st_on_arg1 = id;

    allocate_new_laser(1, &inner);
}

laserOffset @ 704 (int id, float x, float y) {
    Laser* l = find_laser_by_id(id);
    if (l) l->set_offset(x, y, 0.f);
}

laserTrajectory @ 705 (int id, float xs, float ys) {
    Laser* l = find_laser_by_id(id);
    if (l) l->set_speed(xs, ys, 0.f);
}

laserStLength @ 706 (int id, float s) {
    Laser* l = find_laser_by_id(id);
    if (l) l->set_speed(s);
}

laserStWidth @ 707 (int id, float w) {
    Laser* l = find_laser_by_id(id);
    if (l) l->set_width(w);
}

laserStAngle @ 708 (int id, float s) {
    Laser* l = find_laser_by_id(id);
    if (l) l->set_angle(a);
}

laserStRotation @ 709 (int id, float avel) {
    Laser* l = find_laser_by_id(id);
    if (dynamic_cast<LaserInfinite*>(l))
        dynamic_cast<LaserInfinite*>(l)->getInner()
            .laser_inf_angular_velocity = avel;
}

laserStEnd @ 710 (int id) {
    Laser* l = find_laser_by_id(id);
    while (l) {
        l->cancel(0, 0);
        l->set_id(0);
        l = find_laser_by_id(id);
    }
}

laserCuOn @ 711 (int etid) {
    LaserCurveInner_t inner;

    for (int i = 0; i < 20; i++) inner.ex[i] = enemy.BSs[etid].ex[i];

    if (enemy.bulletOrigins[etid].z <= 0.9f) {
        inner.start_pos = enemy.final_pos.pos + enemy.bulletOffsets[etid];
    } else {
        inner.start_pos = {
            enemy.bulletOrigins[etid].x + enemy.bulletOffsets[etid].x,
            enemy.bulletOrigins[etid].y + enemy.bulletOffsets[etid].y,
            0.f
        };
    }

    inner.type = enemy.BSs[etid].type;
    inner.color = enemy.BSs[etid].__color;
    inner.ang_aim = enemy.BSs[etid].ang_aim;
    inner.laser_time_start = enemy.BSs[etid].__laser_timing_start;
    inner.init_1 = 1;
    inner.shot_sfx = enemy.BSs[etid].shot_sfx;
    inner.shot_transform_sfx = enemy.BSs[etid].__shot_transform_sfx;
    inner.spd_1 = enemy.BSs[etid].spd1;
    inner.laser_new_arg4 = enemy.BSs[etid].__laser_new_arg_4;
    inner.distance = enemy.BSs[etid].distance;

    allocate_new_laser(2, &inner);
}

// get zRotation of anm0
// BulletManager::cancel_rectangle_as_bomb(z_rot,
//                  enemy.final_pos.pos, {w, h}, 1); TODO
etCancelRect @ 712 (float w, float h) {
    _notImpl
}

laserBeOn @ 713 (int a, int b) {
    LaserBeamInner_t inner;

    // TODO(ClementChambard)

    allocate_new_laser(3, &inner);
}

laserBeCall @ 714 (int id, int arg) {
    Laser* l = find_laser_by_id(id);
    if (dynamic_cast<LaserBeam*>(l))
        dynamic_cast<LaserBeam*>(l)->method_8(arg);
}


