!PUSH(val) = stripped {
    eclStackPush(&cont->stack, val);
}

!POPS(var) = stripped {
    int32_t var;
    eclStackPop(&cont->stack, var);
}

!POP2S(var1 var2) = stripped {
    POPS(var1)
    POPS(var2)
}

!CALCS(operator) = stripped {
    POP2S(a#b)
    PUSH(b operator a)
}

!POPF(var) = stripped {
    float var;
    eclStackPop(&cont->stack, var);
}

!POP2F(var1 var2) = stripped {
    POPF(var1)
    POPF(var2)
}

!CALCF(operator) = stripped {
    POP2F(a#b)
    PUSH(b operator a)
}

delete @ 1 () {
    cont->currentLocation.sub_id = -1;
    cont->currentLocation.offset = -1;
    delete_self;
}

return @ 10 () {
    eclPopContext(cont);
    exit;

    // TODO(ClementChambard)
    int bo = cont->stack.baseOffset;
    eclStackPop(&cont->stack, cont->stack.baseOffset, true);
    cont->stack.stackOffset = bo;
    if (cont->stack.stackOffset == 0) {
        cont->currentLocation.sub_id = -1;
        cont->currentLocation.offset = -1;
        delete_self;
    }
    eclStackPop(&cont->stack, cont->currentLocation.sub_id, true);
    eclStackPop(&cont->stack, cont->currentLocation.offset, true);
    eclStackPop(&cont->stack, cont->time, true);
    eclStackPop(&cont->stack, cont->stack.stackOffset, true);
}

call @ 11 (string sub) noprint vararg {
    cont->currentLocation.offset += instr->size;
    // Should be ok
    // if (EclRunContext::init_context_from_args(cont,cont,0)) {
    //    cont->currentLocation.sub_id = -1;
    //    cont->currentLocation.offset = -1;
    //    delete_self;
    //}

    std::vector<EclStackItem_t> args_to_put_on_stack;

    // PRINTING
    ON_PRINT(
        std::cout << "@" << sub << "(";
    )
    for (int i = 0; i < VA_COUNT; i++) {
        ON_PRINT(
            if (i > 0) std::cout << ", ";
        )
        if (VA_INT) {
            VA_GET_S(x)
            ON_PRINT(std::cout << x;)
            args_to_put_on_stack.push_back(x);
        } else if (VA_FLOAT) {
            VA_GET_F(x)
            ON_PRINT(std::cout << x;)
            args_to_put_on_stack.push_back(x);
        }
    }
    VA_END

    eclPushContext(cont);
    cont->currentLocation.sub_id = fileManager->getSubId(sub);
    int i = 0;
    for (auto e : args_to_put_on_stack)
        cont->stack.data[cont->stack.stackOffset + i++] = e;

    // PRINTING
    ON_PRINT(
        std::cout << ")\n";
    )
    exit;
}

jump @ 12 (int offset, float time) { /* OK */
    cont->time += time;
    cont->currentLocation.offset += offset;
    exit;
}

jumpEq @ 13 (int offset, float time) { /* OK */
    POPS(top)
    if (!top) {
        cont->currentLocation.offset += offset;
        cont->time += time;
        exit;
    }
}

jumpNeq @ 14 (int offset, float time) { /* OK */
    POPS(top)
    if (top) {
        cont->currentLocation.offset += offset;
        cont->time += time;
        exit;
    }
}

callAsync @ 15 (string sub) noprint vararg {
    EclRunContext_t* c = new EclRunContext_t();
    c->currentLocation.sub_id = fileManager->getSubId(sub);
    c->difficultyMask = context.primaryContext.difficultyMask;
    EclRunContextList_t* l = asyncListHead;
    asyncListHead = new EclRunContextList_t();
    asyncListHead->next = l;
    if (asyncListHead->next)
        asyncListHead->next->prev = asyncListHead;
    asyncListHead->entry = c;

    // PRINTING
    ON_PRINT(
        std::cout << "@" << sub << "(";
    )
    for (int i = 0; i < VA_COUNT; i++) {
        ON_PRINT(
            if (i > 0) std::cout << ", ";
        )
        if (VA_INT) {
            VA_GET_S(x)
            ON_PRINT(std::cout << x;)
            c->stack.data[c->stack.stackOffset + i - 1].asInt = x;
            c->stack.data[c->stack.stackOffset + i - 1].asFloat = x;
        } else if (VA_FLOAT) {
            VA_GET_F(x)
            ON_PRINT(std::cout << x;)
            c->stack.data[c->stack.stackOffset + i - 1].asInt = x;
            c->stack.data[c->stack.stackOffset + i - 1].asFloat = x;
        }
    }
    VA_END
    ON_PRINT(
        std::cout << ") async\n";
    )
}

callAsyncId @ 16 (string sub, int id) noprint vararg {
    EclRunContext_t* c = new EclRunContext_t();
    c->currentLocation.sub_id = fileManager->getSubId(sub);
    c->difficultyMask = context.primaryContext.difficultyMask;
    c->asyncId = id;
    EclRunContextList_t* l = asyncListHead;
    asyncListHead = new EclRunContextList_t();
    asyncListHead->next = l;
    if (asyncListHead->next)
        asyncListHead->next->prev = asyncListHead;
    asyncListHead->entry = c;

    // PRINTING
    ON_PRINT(
        std::cout << "@" << sub << "(";
    )
    for (int i = 0; i < VA_COUNT; i++) {
        ON_PRINT(
            if (i > 0) std::cout << ", ";
        )
        if (VA_INT) {
            VA_GET_S(x)
            ON_PRINT(std::cout << x;)
            c->stack.data[c->stack.stackOffset + i - 1].asInt = x;
            c->stack.data[c->stack.stackOffset + i - 1].asFloat = x;
        } else if (VA_FLOAT) {
            VA_GET_F(x)
            ON_PRINT(std::cout << x;)
            c->stack.data[c->stack.stackOffset + i - 1].asInt = x;
            c->stack.data[c->stack.stackOffset + i - 1].asFloat = x;
        }
    }
    VA_END
    ON_PRINT(
        std::cout << ") async " << id << "\n";
    )
}

/////// OK FROM HERE /////////
killAsync @ 17 (int id) {
    for (EclRunContextList_t* node = asyncListHead;
         node != nullptr; node = node->next) {
        if (node->entry->asyncId == id) {
            node->entry->currentLocation.sub_id = -1;
            node->entry->currentLocation.offset = -1;
            break;
        }
    }
}

unknown18 @ 18 (int id) {
    for (EclRunContextList_t* node = asyncListHead;
         node != nullptr; node = node->next) {
        if (node->entry->asyncId == id) {
            node->entry->set_by_ins_18_19 |= 1;
            break;
        }
    }
}

unknown19 @ 19 (int id) {
    for (EclRunContextList_t* node = asyncListHead;
        node != nullptr; node = node->next) {
        if (node->entry->asyncId == id) {
            node->entry->set_by_ins_18_19 &= 0xfffffffe;
            break;
        }
    }
}

unknown20 @ 20 (int id, int b) {
    for (EclRunContextList_t* node = asyncListHead;
         node != nullptr; node = node->next) {
        if (node->entry->asyncId == id) {
            node->entry->set_by_ins_20 = b;
            break;
        }
    }
}

killAllAsync @ 21 () {
    for (EclRunContextList_t* node = asyncListHead;
         node != nullptr; node = node->next) {
        node->entry->currentLocation.sub_id = -1;
        node->entry->currentLocation.offset = -1;
    }
}

// NOPed in the code
debug22 @ 22 (int a, string b) {}

wait @ 23 (int time) {
    cont->time -= time;
}

waitf @ 24 (float time) {
    cont->time -= time;
}

// NOPed in the code
printf @ 30 (string str) {}

// NOPed in the code
unknown31 @ 31 () {}

stackAlloc @ 40 (int s) {
    eclAllocVariables(cont, s);
    // TODO(ClementChambard) see in the function
}

stackDlloc @ 41 () {
    cont->stack.stackOffset--;
    int bo = cont->stack.baseOffset;
    cont->stack.baseOffset = cont->stack.data[cont->stack.stackOffset].asInt;
    cont->stack.stackOffset = bo;
}

/*     BASIC MATHS     */
pushi @ 42 (int num) { PUSH(num) }

seti @ 43 (int& var) {
    POPS(a)
    var = a;
}

pushf @ 44 (float num) { PUSH(num) }

setf @ 45 (float& var) {
    POPF(a)
    var = a;
}

addi @ 50 () { CALCS(+) }
addf @ 51 () { CALCF(+) }
subi @ 52 () { CALCS(-) }
subf @ 53 () { CALCF(-) }
muli @ 54 () { CALCS(*) }
mulf @ 55 () { CALCF(*) }
divi @ 56 () {
    POP2S(a#b)
    if (a != 0)
        PUSH(b / a)
    else
        PUSH(0)
}
divf @ 57 () { CALCF(/) }
modi @ 58 () {
    POP2S(a#b)
    if (a != 0)
        PUSH(b % a)
    else
        PUSH(0)
}
equi @ 59 () { CALCS(==) }
equf @ 60 () { CALCF(==) }
neqi @ 61 () { CALCS(!=) }
neqf @ 62 () { CALCF(!=) }
lesi @ 63 () { CALCS(<) }
lesf @ 64 () { CALCF(<) }
leqi @ 65 () { CALCS(<=) }
leqf @ 66 () { CALCF(<=) }
grei @ 67 () { CALCS(>) }
gref @ 68 () { CALCF(>) }
geqi @ 69 () { CALCS(>=) }
geqf @ 70 () { CALCF(>=) }
noti @ 71 () {
    POPS(a)
    PUSH(!a)
}
notf @ 72 () {
    POPF(a) 
    PUSH(!a)
}
or @ 73 () { CALCS(||) }
and @ 74 () { CALCS(&&) }
xor @ 75 () { CALCS(^) }
bor @ 76 () { CALCS(|) }
band @ 77 () { CALCS(&) }
deci @ 78 (int& v) {
    PUSH(v) 
    v--;
}
ssin @ 79 () {
    POPF(a) 
    PUSH(sin(a))
}
scos @ 80 () {
    POPF(a) 
    PUSH(cos(a))
}
negi @ 83 () {
    POPS(a) 
    PUSH(-a)
}
negf @ 84 () {
    POPF(a) 
    PUSH(-a)
}
sqrt @ 88 () {
    POPF(a) 
    PUSH(sqrt(a))
}

/*      ADVANCED MATH      */
circlePos @ 81 (float& vx, float& vy, float an, float ra) {
    vx = ra * cos(an);
    vy = ra * sin(an);
}

validRad @ 82 (float& var) {
    math::angle_normalize(var);
}

sqSum @ 85 (float& v, float x, float y) {
    v = math::point_distance_sq(0, 0, x, y);
}

sqSumRt @ 86 (float& v, float x, float y) {
    v = math::point_distance(0, 0, x, y);
}

getAng @ 87 (float& v, float x1, float y1, float x2, float y2) {
    v = math::point_direction(x1, y1, x2, y2);
}

linFunc @ 89 (float& v, float a, float x) {
    if (x - a <= PI) {
        if (PI < a - x)
            v = x - a + PI2;
        else
            v = x - a;
    } else {
        v = x - a - PI2;
    }
}

ptRot @ 90 (float& vx, float& vy, float x, float y, float a) {
    vx = x * cos(a) - y * sin(a);
    vy = y * cos(a) + x * sin(a);
}

floatTime @ 91 (int slot, float& var, int t, int m, float i, float f) {
    cont->float_interps_locs[slot] = __var_var;
    cont->float_i[slot].start(i, f, t, m);
    var = i;
}

floatTimeEx @ 92 (int slot, float& var, int t, int m, float i, float f, float a, float b) {
    cont->float_interps_locs[slot] = __var_var;
    cont->float_i[slot].start_ex(i, f, a, b, t, m);
    var = i;
}

RandRadius @ 93 (float& vx, float& vy, float r1, float r2) {
    r1 += Random::Float01() * (r2 - r1);
    float a = Random::Angle();
    vx = r1 * cos(a);
    vy = r1 * sin(a);
}

